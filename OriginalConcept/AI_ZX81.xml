<?xml version="1.0"?>
<!--
Generated by VSdocman, see http://www.helixoft.com
-->
<doc>
  <assembly>
    <name>AI_ZX81</name>
  </assembly>
  <members>
    <member name="N:AI_ZX81.GRAMMARS">
    </member>
    <member name="T:AI_ZX81.GRAMMARS.AST_Grammar">
      <summary>
Production Rules for Grammar</summary>
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.CreateGrammar">
      <summary>
Returns a list of Syntax Grammar If Phrase is matched then then it can be returned populated the NAME of the Syntax is the name of the relative function tokens added to the syntax will be the parameters for the executor or Code transpiler.</summary>
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.AddMathOperation">
      <summary>
_ADD -&gt; var/number/float + var/number/float _MINUS -&gt; var/number/float - var/number/float _DIVIDE -&gt; var/number/float / var/number/float _MULTIPLY -&gt; var/number/float * var/number/float</summary>
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.AddConditionalOperation">
      <summary>
EQUALS / NOT -&gt; var/bool/number/float = var/bool/number/float LESS THAN / NOT -&gt; var/number/float = var/number/float GREATER THAN / NOT -&gt; var/number/float = var/number/float</summary>
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.Add_ASSIGN_EQUALS_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.Add_PRINT_STR_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.Add_PRINT_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.Add_PRINT_BOOL_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.Add_PRINT_VARIABLE_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.Add_PRINT_INT_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.Add_DIM_AS_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.Add_DIM_AS_EQUALS_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_FOR_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_NEXT_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_IF_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_THEN_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_ELSE_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_END_IF_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_ELSE_END_IF_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_LOOP_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_DO_WHILE_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_WHILE_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_CODEBLOCK_FUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.AST_Grammar.ADD_OPERATION_FUNCTION">
    </member>
    <member name="T:AI_ZX81.GRAMMARS.PL_Grammar">
      <summary>
Used by the Lexer to Detect and create tokens Which form statments to be used by a Parser</summary>
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.CreatePLGrammar">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.AddNumbers(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.GrammarRule}@)">
      <param name="Rulelist">
</param>
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.GetNumberRule">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.GetStartCodeBlockRule">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.GetEndCodeBlockRule">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.GetLettersRule">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.AddLetters(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.GrammarRule}@)">
      <param name="Rulelist">
</param>
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.AddMathOperators(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.GrammarRule}@)">
      <param name="Rulelist">
</param>
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.ADD_PLUS">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.ADD_MINUS">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.ADD_MULTIPLY">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.ADD_DIVIDE">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.GetMathOperators">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.GetConditionalOperators">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.AddGreaterThan">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.AddLessThan">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.AddNOT">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.AddOperationBeginPoint">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.AddOperationEndPoint">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.AddListBeginPoint">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.AddListEndPoint">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.PL_Grammar.AddFloatPoint">
    </member>
    <member name="T:AI_ZX81.GRAMMARS.EnglishLanguageGrammar">
      <summary>
Used as For seaperate Grammar Projects (Natural Language interface)</summary>
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.AddEOF">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.SIMPLECONSTITUANTGRAMMAR">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.AddNewline">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.AddWhiteSpce">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDNUMBER">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDCONJUNCTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDINTERJECTION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDNOUN">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDVERB">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDPREPOSITION">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDADVERB">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDDETERMINER">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDADJECTIVE">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDQUANTIFIER">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDQUESTWORD">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDPRONOUN">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDAUXVERB">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDPRONOUNPLACE">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDPRONOUNNAME">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDTRANSITIVEVERB">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDINTRANSITIVEVERB">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.SIMPLEPHRASEGRAMMAR">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDDETERMINATEPHRASES">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDNOUNPHRASES">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDADVERBPHRASES">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDADJECTIVEPHRASES">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDPREPOSITIONALPHRASES">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDVERBPHRASES">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.COMPLEXPHRASEGRAMMAR">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.SIMPLESENTENCEGRAMMAR">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDSIMPLE">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDCOMPOUND">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.ADDCOMPLEX">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.COMPLEXSENTENCEGRAMMAR">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.IMPERATIVE">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.DECLARITIVE">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.DECLARITIVE_CONCEPT">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.INTERROGATIVE_CONCEPT">
      <summary>
enables for recogognition of Intergative Sentences for retriving informaion stored in concepts</summary>
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.SUBJECT">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.PREDICATE">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.EXCLAMITORY">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.INTERROGATIVE">
    </member>
    <member name="M:AI_ZX81.GRAMMARS.EnglishLanguageGrammar.SIMPLECONCEPTNETPHRASEGRAMMAR">
    </member>
    <member name="N:AI_ZX81.Compiler">
    </member>
    <member name="T:AI_ZX81.Compiler.ClassLexer">
      <summary>
Used to decode language based upon a Grammar Terms are detected and assigned. Tokens are Produced on execution of the Class; these can be transpiled and converted into Expression Nodes to be assembled in an Abstract Syntax Tree. The Abstract Tree can be executed or Statements reasssbled, into a Target Language for execution or compiling to an output such as EXE/DLL.</summary>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.ENG_Lexer(System.String@)">
      <param name="Code">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.GetTokenExprTree(System.Collections.Generic.List{System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.Token}}@)">
      <summary>
Returns Node ready for display in a tree view control</summary>
      <param name="Program">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.GetTokenExprTree(AI_ZX81.ModuleKnowledgeStructures.AbstractTokenTree@)">
      <summary>
Returns Node ready for display in a tree view control</summary>
      <param name="Program">
</param>
    </member>
    <member name="F:AI_ZX81.Compiler.ClassLexer.mCurrentState">
    </member>
    <member name="P:AI_ZX81.Compiler.ClassLexer.CurrentState">
    </member>
    <member name="F:AI_ZX81.Compiler.ClassLexer.zDefinedTokens">
    </member>
    <member name="P:AI_ZX81.Compiler.ClassLexer.Defined">
    </member>
    <member name="F:AI_ZX81.Compiler.ClassLexer.mGrammar">
    </member>
    <member name="P:AI_ZX81.Compiler.ClassLexer.CurrentGrammar">
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.Tokenizer(System.String@)">
      <summary>
Returns Characters in String as list</summary>
      <param name="InputStr">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CheckTokenByRule(System.String@,AI_ZX81.ModuleKnowledgeStructures.GrammarRule)">
      <summary>
Checks if String token Matches grammar tule</summary>
      <param name="CurrentToken">
</param>
      <param name="rule">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CheckCurrentToken(System.String@,System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.GrammarRule}@)">
      <summary>
Checks current token to see if it is in TokenList</summary>
      <param name="Token">
</param>
      <param name="iRuleList">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.GetTokenRule(System.String@,System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.GrammarRule}@)">
      <summary>
Checks current token to see if it is in TokenList.COMPONENTSTRINGS (all reserved terms which point to this term) Allowing for multiple ways to ie: DIM/PUBLIC/PRIVATE</summary>
      <param name="Token">
</param>
      <param name="iRuleList">
</param>
    </member>
    <member name="F:AI_ZX81.Compiler.ClassLexer.mAbstract_Token_Tree">
    </member>
    <member name="P:AI_ZX81.Compiler.ClassLexer.Abstract_Token_Tree">
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.PL_Lexer(System.String@)">
      <summary>
Returns a list of tokens found in the text</summary>
      <param name="Code">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.#ctor(System.String@,System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.GrammarRule}@,System.String@)">
      <summary>
This class is to create lexical items from gramar rules THe MAIN Funcyion LEXER creates the Tokens Returning a set of tokens from the given CODE BLOCK The tokens can be passed to a transpiler to Create an Advanced Token Node associated to the language being transpiled to.</summary>
      <param name="Codeblock">
</param>
      <param name="GRAM">
</param>
      <param name="Lang">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CheckIfContainsMathOperator(System.String@)">
      <summary>
Used to check if NumericExpression Contains Non Numerics</summary>
      <param name="NumericExpression">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CheckIfContainsComparisonOperator(System.String@)">
      <summary>
Checks if Expression String contians Comparison Operator</summary>
      <param name="NumericExpression">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.ExpressionNumericCapture(System.String@)">
      <summary>
Attempts to capture a numeric from a string</summary>
      <param name="CurrentChar">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CheckNumericExpressions(System.String@,System.String@,AI_ZX81.ModuleKnowledgeStructures.SearchState@)">
      <summary>
Checks for part of a numeric string based upon current search state</summary>
      <param name="CurrentChar">
</param>
      <param name="CurrentToken">
Currently accuilated token</param>
      <param name="CurrState">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CheckStringExpressions(System.String@,System.String@,AI_ZX81.ModuleKnowledgeStructures.SearchState@)">
      <summary>
checks for string token based on the current state</summary>
      <param name="CurrentChar">
</param>
      <param name="CurrentToken">
currently accured token</param>
      <param name="CurrentState">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CheckTextExpressions(System.String@,System.String@,AI_ZX81.ModuleKnowledgeStructures.SearchState@)">
      <summary>
Detects text expressions based on the current state and accumalated token</summary>
      <param name="CurrentChar">
</param>
      <param name="CurrentToken">
</param>
      <param name="CurrState">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CheckNewline(System.String@,System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.GrammarRule}@)">
      <param name="CurrentToken">
</param>
      <param name="RuleList">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CheckGrammarTerms(System.String@,System.String@,AI_ZX81.ModuleKnowledgeStructures.SearchState@)">
      <summary>
Checks for terms in Grammar based on the current state and accualated token</summary>
      <param name="CurrentChar">
</param>
      <param name="CurrentToken">
</param>
      <param name="CurrentState">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CollectStatements(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.Token}@)">
      <summary>
Collects tokens into statements by newline</summary>
      <param name="DefinedTokens">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CollectCodeBlocks(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.Token}@)">
      <summary>
Collects tokens into codeBLocks by COnvert to a single token containing the code cblock Should be executes on a per statment basis not on a program basis</summary>
      <param name="DefinedTokens">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.CollectOperationBlocks(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.Token}@)">
      <summary>
Collects Operation BLocks and add them to thier sub Codeblock</summary>
      <param name="DefinedTokens">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.DetectCodeBlock(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.Token}@)">
      <summary>
Attempts to detect if codeblock in token list</summary>
      <param name="DefinedTokens">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.DetectOperationBlock(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.Token}@)">
      <summary>
Attempts to detect operators in the token list</summary>
      <param name="DefinedTokens">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassLexer.RemoveWhiteSpace(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.Token}@)">
      <summary>
Removes whitespace tokens from the token list</summary>
      <param name="DefinedTokens">
</param>
    </member>
    <member name="T:AI_ZX81.Compiler.Expression">
      <summary>
To be Used as a Node in a Syntax Tree</summary>
    </member>
    <member name="F:AI_ZX81.Compiler.Expression.Expr">
    </member>
    <member name="M:AI_ZX81.Compiler.Expression.Evaluate(AI_ZX81.ZX81_RAM@)">
      <param name="ParentEnvironment">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.Expression.GetExpr">
    </member>
    <member name="F:AI_ZX81.Compiler.Expression.NodeType">
      <summary>
Type = "Parameter" / "Variable Assignment"</summary>
    </member>
    <member name="M:AI_ZX81.Compiler.Expression.#ctor(System.String@)">
      <param name="NodeType">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.Expression.ToJson">
    </member>
    <member name="T:AI_ZX81.Compiler.ConstantExpression">
      <summary>
Used For values ie:Integers</summary>
    </member>
    <member name="F:AI_ZX81.Compiler.ConstantExpression.iValue">
      <summary>
Used as a literal for the final data item Value Held ie: 5 or CAT</summary>
    </member>
    <member name="F:AI_ZX81.Compiler.ConstantExpression.VarType">
      <summary>
ie: Integer / String</summary>
    </member>
    <member name="M:AI_ZX81.Compiler.ConstantExpression.GetValue">
    </member>
    <member name="M:AI_ZX81.Compiler.ConstantExpression.Evaluate(AI_ZX81.ZX81_RAM@)">
      <param name="ParentEnvironment">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ConstantExpression.#ctor(System.String@,System.String@,System.String@)">
      <param name="NodeType">
</param>
      <param name="Value">
</param>
      <param name="Type">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ConstantExpression.#ctor(System.String@)">
      <param name="NodeType">
</param>
    </member>
    <member name="T:AI_ZX81.Compiler.UnaryExpression">
    </member>
    <member name="F:AI_ZX81.Compiler.UnaryExpression.Identifier">
    </member>
    <member name="F:AI_ZX81.Compiler.UnaryExpression.ParentEnv">
    </member>
    <member name="M:AI_ZX81.Compiler.UnaryExpression.#ctor(System.String@,System.String@,System.String@,System.String@,AI_ZX81.ZX81_RAM@)">
      <param name="NodeType">
</param>
      <param name="iName">
</param>
      <param name="Value">
</param>
      <param name="Type">
</param>
      <param name="Env">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.UnaryExpression.Evaluate(AI_ZX81.ZX81_RAM@)">
      <param name="ParentEnvironment">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.UnaryExpression.GetValue">
    </member>
    <member name="M:AI_ZX81.Compiler.UnaryExpression.GetName">
    </member>
    <member name="T:AI_ZX81.Compiler.BinaryExpression">
      <summary>
The Binary Expression is a function, the execution of the node structure is performed by the get data functions This class must be inherited and its Get Data function Implemented With its custom Used for Functions A+1 = iOperator = "+" Nodetype = "ADD" (LeftNode = ParameterExpression(Parameter/5/a/int)) (RightNode = ConstantExpression (number/1/int/))</summary>
    </member>
    <member name="F:AI_ZX81.Compiler.BinaryExpression.iOperator">
      <summary>
Operator such as "+" or "DIM"</summary>
    </member>
    <member name="F:AI_ZX81.Compiler.BinaryExpression.Left">
      <summary>
(LeftNode = ParameterExpression(Parameter/5/a/int))</summary>
    </member>
    <member name="F:AI_ZX81.Compiler.BinaryExpression.Right">
      <summary>
(RightNode = ConstantExpression (number/1/int/))</summary>
    </member>
    <member name="M:AI_ZX81.Compiler.BinaryExpression.#ctor(System.String@,System.String@,System.String@,System.String@,AI_ZX81.ZX81_RAM@)">
      <param name="NodeType">
</param>
      <param name="iName">
</param>
      <param name="Value">
</param>
      <param name="Type">
</param>
      <param name="Env">
</param>
    </member>
    <member name="T:AI_ZX81.Compiler.Body">
      <summary>
A body is a list of statements Which is a list of Binary Expressions. Essentially Each Binary Expression is a single Segment of Code</summary>
    </member>
    <member name="F:AI_ZX81.Compiler.Body.Statements">
    </member>
    <member name="M:AI_ZX81.Compiler.Body.#ctor(System.String@,AI_ZX81.Compiler.Expression@)">
      <param name="Nodetype">
</param>
      <param name="Statment">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.Body.#ctor(System.String@,System.Collections.Generic.List{AI_ZX81.Compiler.Expression}@)">
      <param name="Nodetype">
</param>
      <param name="Program">
</param>
    </member>
    <member name="N:AI_ZX81.ConcreteExpressions">
    </member>
    <member name="T:AI_ZX81.ConcreteExpressions.ConditionalOperation">
    </member>
    <member name="F:AI_ZX81.ConcreteExpressions.ConditionalOperation.Env">
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.ConditionalOperation.#ctor(AI_ZX81.Compiler.ConstantExpression@,System.String,AI_ZX81.Compiler.ConstantExpression,AI_ZX81.ZX81_RAM@)">
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.ConditionalOperation.GetValue">
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.ConditionalOperation.Evaluate(AI_ZX81.ZX81_RAM@)">
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.ConditionalOperation.EvaluateBoolean(AI_ZX81.Compiler.ConstantExpression@,System.String@,AI_ZX81.Compiler.ConstantExpression@)">
      <summary>
Evaluate node values ( imeadiatly invoked expression )</summary>
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
    </member>
    <member name="T:AI_ZX81.ConcreteExpressions.AddativeOperation">
    </member>
    <member name="F:AI_ZX81.ConcreteExpressions.AddativeOperation.Env">
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.AddativeOperation.#ctor(AI_ZX81.Compiler.ConstantExpression@,System.String,AI_ZX81.Compiler.ConstantExpression,AI_ZX81.ZX81_RAM@)">
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.AddativeOperation.GetValue">
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.AddativeOperation.Evaluate(AI_ZX81.ZX81_RAM@)">
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.AddativeOperation.EvaluateAddative(AI_ZX81.Compiler.ConstantExpression@,System.String@,AI_ZX81.Compiler.ConstantExpression@)">
      <summary>
Enables for evaluation of the node / Imediatly invoked expression</summary>
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
    </member>
    <member name="T:AI_ZX81.ConcreteExpressions.MultiplicativeOperation">
    </member>
    <member name="F:AI_ZX81.ConcreteExpressions.MultiplicativeOperation.env">
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.MultiplicativeOperation.#ctor(AI_ZX81.Compiler.ConstantExpression@,System.String,AI_ZX81.Compiler.ConstantExpression,AI_ZX81.ZX81_RAM@)">
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.MultiplicativeOperation.GetValue">
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.MultiplicativeOperation.Evaluate(AI_ZX81.ZX81_RAM@)">
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.MultiplicativeOperation.EvaluateMultiplicative(AI_ZX81.Compiler.ConstantExpression@,System.String@,AI_ZX81.Compiler.ConstantExpression@)">
      <summary>
Allows for evaluation of the node : Imeadialty invoked expression</summary>
      <param name="Left">
</param>
      <param name="iOperator">
</param>
      <param name="Right">
</param>
    </member>
    <member name="T:AI_ZX81.ConcreteExpressions.PrintFunction">
    </member>
    <member name="F:AI_ZX81.ConcreteExpressions.PrintFunction.ToPrint">
    </member>
    <member name="F:AI_ZX81.ConcreteExpressions.PrintFunction.ParentEnv">
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.PrintFunction.#ctor(AI_ZX81.Compiler.UnaryExpression@,AI_ZX81.ZX81_RAM@)">
      <param name="ToPrint">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.PrintFunction.#ctor(AI_ZX81.Compiler.ConstantExpression@,AI_ZX81.ZX81_RAM@)">
      <param name="ToPrint">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.PrintFunction.#ctor(AI_ZX81.Compiler.BinaryExpression@)">
      <param name="ToPrint">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.PrintFunction.#ctor(AI_ZX81.ConcreteExpressions.ConditionalOperation@,AI_ZX81.ZX81_RAM@)">
      <param name="ToPrint">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.PrintFunction.#ctor(AI_ZX81.ConcreteExpressions.MultiplicativeOperation@,AI_ZX81.ZX81_RAM@)">
      <param name="ToPrint">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.PrintFunction.#ctor(AI_ZX81.ConcreteExpressions.AddativeOperation@,AI_ZX81.ZX81_RAM@)">
      <param name="ToPrint">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.PrintFunction.Evaluate(AI_ZX81.ZX81_RAM@)">
      <param name="ParentEnV">
</param>
    </member>
    <member name="T:AI_ZX81.ConcreteExpressions.IfFunction">
    </member>
    <member name="F:AI_ZX81.ConcreteExpressions.IfFunction.Statements">
    </member>
    <member name="F:AI_ZX81.ConcreteExpressions.IfFunction.Conditional">
    </member>
    <member name="F:AI_ZX81.ConcreteExpressions.IfFunction.Env">
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.IfFunction.#ctor(AI_ZX81.ConcreteExpressions.ConditionalOperation@,AI_ZX81.Compiler.Body@,AI_ZX81.ZX81_RAM@)">
      <param name="Condition">
</param>
      <param name="Block">
</param>
      <param name="ParentEnv">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.IfFunction.GetValue">
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.IfFunction.Evaluate(AI_ZX81.ZX81_RAM@)">
      <param name="ParentEnv">
</param>
    </member>
    <member name="T:AI_ZX81.ConcreteExpressions.LoopFunction">
    </member>
    <member name="F:AI_ZX81.ConcreteExpressions.LoopFunction.body">
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.LoopFunction.#ctor(AI_ZX81.Compiler.Body@,AI_ZX81.ZX81_RAM@)">
      <param name="Body">
</param>
      <param name="ParentEnvironment">
</param>
    </member>
    <member name="M:AI_ZX81.ConcreteExpressions.LoopFunction.Evaluate(AI_ZX81.ZX81_RAM@)">
      <param name="ParentEnvironment">
</param>
    </member>
    <member name="T:AI_ZX81.Compiler.ClassParser">
      <summary>
The Parse / Generator is used to manage statements created by the Tokenizer / Lexer the Lexical statments are used to generate Abstract tokens Which are associated to Specific Expressions Which can be used to execute code to produce executable results or generate code for another environment or language to be executed on the platform. An Abstract Syntax Grammar should be created from all required comands with thier associated expressions loaded</summary>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.GetParseAST_Tree(AI_ZX81.ModuleKnowledgeStructures.AbstractTokenTree@)">
      <summary>
Returns Abstract Syntax tree If Fails then syntax is incorrect not matching any known function</summary>
      <param name="AST">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.GetSyntax(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.Token}@,AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax@)">
      <summary>
Given as statment (Token Statment) Return an Abstract Syntax Token (Used for execution)</summary>
      <param name="DefinedTokens">
Statment From Lexer</param>
      <param name="KnownSyntax">
Known Syntax Item(Parser Gramar)</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.executeON_CPU(AI_ZX81.STACK_VM.ZX81_VM@,System.Collections.Generic.List{System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}}@)">
      <param name="VM">
</param>
      <param name="POPULATED_TREE">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.CleanTree(System.Collections.Generic.List{System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}}@)">
      <param name="POPULATED_TREE">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.ParseTree(System.Collections.Generic.List{System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}}@)">
      <param name="POPULATED_TREE">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.ParseFOR_NEXT(System.Collections.Generic.List{System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}}@)">
      <param name="POPULATED_TREE">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.ParseIF_ENDIF(System.Collections.Generic.List{System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}}@)">
      <param name="POPULATED_TREE">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.ParseWHILE_LOOP(System.Collections.Generic.List{System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}}@)">
      <param name="POPULATED_TREE">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.CheckWHILE_LOOP(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}@)">
      <param name="POPULATED_TREE">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.CheckIF_ENDIF(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}@)">
      <param name="POPULATED_TREE">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.CheckTHEN_ELSE(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}@)">
      <param name="POPULATED_TREE">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.RemoveEmptySyntax(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}@)">
      <param name="lst">
</param>
    </member>
    <member name="M:AI_ZX81.Compiler.ClassParser.CheckFOR_NEXT(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}@)">
      <param name="POPULATED_TREE">
</param>
    </member>
    <member name="T:AI_ZX81.Form_DisplayHelpNotes">
    </member>
    <member name="T:AI_ZX81.Form_DisplayHelpNotes.iClearText">
      <param name="mTextbox">
</param>
      <param name="Message">
</param>
    </member>
    <member name="T:AI_ZX81.Form_DisplayHelpNotes.UpdateText">
      <param name="mTextbox">
</param>
      <param name="Message">
</param>
    </member>
    <member name="T:AI_ZX81.Form_DisplayHelpNotes.UpdateTitle">
      <param name="mTextbox">
</param>
      <param name="Message">
</param>
    </member>
    <member name="M:AI_ZX81.Form_DisplayHelpNotes.ClearText">
    </member>
    <member name="M:AI_ZX81.Form_DisplayHelpNotes.DisplayText(System.String)">
      <param name="NewText">
</param>
    </member>
    <member name="M:AI_ZX81.Form_DisplayHelpNotes.SetTitle(System.String)">
      <param name="NewText">
</param>
    </member>
    <member name="M:AI_ZX81.Form_DisplayHelpNotes._iClearText(System.Windows.Forms.RichTextBox@,System.String@)">
      <param name="mTextbox">
</param>
      <param name="Message">
</param>
    </member>
    <member name="M:AI_ZX81.Form_DisplayHelpNotes._UpdateText(System.Windows.Forms.RichTextBox@,System.String@)">
      <param name="mTextbox">
</param>
      <param name="Message">
</param>
    </member>
    <member name="M:AI_ZX81.Form_DisplayHelpNotes._UpdateTitle(System.Windows.Forms.Form@,System.String@)">
      <param name="mTextbox">
</param>
      <param name="Message">
</param>
    </member>
    <member name="M:AI_ZX81.Form_DisplayHelpNotes.Form_DisplayText_Load(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:AI_ZX81.Form_DisplayHelpNotes.Dispose(System.Boolean)">
      <param name="disposing">
</param>
    </member>
    <member name="F:AI_ZX81.Form_DisplayHelpNotes.components">
    </member>
    <member name="M:AI_ZX81.Form_DisplayHelpNotes.InitializeComponent">
    </member>
    <member name="T:AI_ZX81.FormDevIDE">
    </member>
    <member name="M:AI_ZX81.FormDevIDE.Print(System.String@)">
      <param name="Userinput">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.CLS">
    </member>
    <member name="M:AI_ZX81.FormDevIDE.Input(System.String@)">
      <param name="Message">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.TextBoxEnterStatments_KeyDown(System.Object,System.Windows.Forms.KeyEventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.ButtonCompile_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.GetCode">
    </member>
    <member name="M:AI_ZX81.FormDevIDE.DisplayOutput(System.String@)">
      <param name="OutputStr">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.DisplayError(System.String@)">
      <param name="ErrorStr">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.ButtonInsertCode_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.LexPL(System.String@)">
      <param name="UserProgram">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.LexEnglish(System.String@)">
      <param name="UserProgram">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.ToJson(System.Object@)">
      <param name="OBJ">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.ButtonExecute_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="F:AI_ZX81.FormDevIDE.CPU">
    </member>
    <member name="M:AI_ZX81.FormDevIDE.ButtonExecuteCpuCode_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.ButtonHelp_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.ButtonParseTree_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.ButtonClearTree_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.CLEAR">
    </member>
    <member name="F:AI_ZX81.FormDevIDE.Parser">
    </member>
    <member name="M:AI_ZX81.FormDevIDE.ButtonExecuteTree_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.RunTree(System.Collections.Generic.List{System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}}@)">
      <param name="tree">
</param>
    </member>
    <member name="M:AI_ZX81.FormDevIDE.Dispose(System.Boolean)">
      <param name="disposing">
</param>
    </member>
    <member name="F:AI_ZX81.FormDevIDE.components">
    </member>
    <member name="M:AI_ZX81.FormDevIDE.InitializeComponent">
    </member>
    <member name="T:AI_ZX81.ModuleKnowledgeStructures">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.ConditionalOperators">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.LogicalOperators">
    </member>
    <member name="T:AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax">
      <summary>
Abstrax Syntax Token Uses the data stored and Assoicated Expression to execute the components from the Lexer Statment; These tokens can finally form the tree for the Program to be executed; These tokens for the final "internal syntax" used by the binary/Uanary/Trinary Expressions The data is stored in the token to be extracted for use by the expression within</summary>
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax.Expr">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax.SyntaxName">
      <summary>
Name of Syntax item - Refers to operation</summary>
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax.RequiredTokens">
      <summary>
Tokens discovered</summary>
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax.SyntaxStatments">
      <summary>
List of posible statements</summary>
    </member>
    <member name="P:AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax.SyntaxSearchStr">
      <summary>
Auto Populated by Items for each list a search string is retruned</summary>
    </member>
    <member name="M:AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax.GetSearchPattern">
      <summary>
Sets the Syntax string from the List of internal syntax str</summary>
    </member>
    <member name="T:AI_ZX81.ModuleKnowledgeStructures.AbstractTokenTree">
      <summary>
Used to Hold the PRogram decoded by the lexer into a single tree Useally Produced by Lexing the Tokenlist into List of Lists after</summary>
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.AbstractTokenTree.Token">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.AbstractTokenTree.Statments">
    </member>
    <member name="T:AI_ZX81.ModuleKnowledgeStructures.SearchState">
      <summary>
Used as a marker when searching for block data</summary>
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.SearchState.State">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.SearchState.CurrentOperation">
    </member>
    <member name="T:AI_ZX81.ModuleKnowledgeStructures.Token">
      <summary>
Used to contain detected tokens</summary>
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.Token.CodeBlock">
    </member>
    <member name="M:AI_ZX81.ModuleKnowledgeStructures.Token.ToJson">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.Token.iDetectedType">
    </member>
    <member name="P:AI_ZX81.ModuleKnowledgeStructures.Token.DetectedType">
      <summary>
Used to denote which token type was detected Once The Token rule has been set the type should be populated</summary>
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.Token.TokenValue">
      <summary>
Value of token</summary>
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.Token.iTokenRule">
    </member>
    <member name="P:AI_ZX81.ModuleKnowledgeStructures.Token.TokenRule">
      <summary>
Token Rule</summary>
    </member>
    <member name="M:AI_ZX81.ModuleKnowledgeStructures.Token.SetType">
    </member>
    <member name="T:AI_ZX81.ModuleKnowledgeStructures.GrammarRule">
      <summary>
USED as syntactic element</summary>
    </member>
    <member name="M:AI_ZX81.ModuleKnowledgeStructures.GrammarRule.ADD(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.GrammarRule}@,AI_ZX81.ModuleKnowledgeStructures.GrammarRule@)">
      <param name="CUSTOMRULES">
</param>
      <param name="NEWGRAMMARRULE">
</param>
    </member>
    <member name="M:AI_ZX81.ModuleKnowledgeStructures.GrammarRule.UPDATE(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.GrammarRule}@,AI_ZX81.ModuleKnowledgeStructures.GrammarRule@)">
      <param name="CUSTOMRULES">
</param>
      <param name="NEWGRAMMARRULE">
</param>
    </member>
    <member name="M:AI_ZX81.ModuleKnowledgeStructures.GrammarRule.CREATE_RULE(System.String@,System.Collections.Generic.List{System.String}@)">
      <summary>
returns a grammar rule to be used in Syntactic BNF GRAMMAR</summary>
      <param name="Tag">
Tag to be used as term / phrase indicator ie "$N$"</param>
      <param name="Terms">
terms defined in tag "CAT,DOG"</param>
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.GrammarRule.ExecutionScript">
      <summary>
Production rule to be used in the generation of the Binary function Associated with the Term/Function/Operation</summary>
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.GrammarRule.TAGSTRING">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.GrammarRule.COMPONENTSTRINGS">
    </member>
    <member name="M:AI_ZX81.ModuleKnowledgeStructures.GrammarRule.ToJson">
    </member>
    <member name="T:AI_ZX81.ModuleKnowledgeStructures.TokenType">
      <summary>
SHOULD BE SHADOWED FOR CUSTOM TOKEN SELECTION</summary>
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._null">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._STRING_TYPE">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._CODEBLOCK">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._LISTBEGIN">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._LISTEND">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._CONDITIONAL_OPERATORS">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._MATHOPERATORS">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._MULTIPLICATIVES">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._ADDATIVES">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._EACH">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._DO">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._WHITE_SPACE">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._NEW_LINE">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._LETTER">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._EOF">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._NUMBER">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._OPERATION">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._LEFT_CODE_BRACKET">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._RIGHT_CODE_BRACKET">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._CODE_BLOCK">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._LEFTBRACKET">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._RIGHTBRACKET">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._DIM">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._ADD">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._MINUS">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._DIVIDE">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._MULTIPLY">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._EQUALS">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._GREATER_THAN">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._LESS_THAN">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._NOT">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._OR">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._AND">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._DECIMAL_POINT">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._FLOAT">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._INT">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._BOOLEAN">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._VARIABLE">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._ARRAY">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._STRING">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._PRINT">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._IF">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._THEN">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._ELSE">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._FOR">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._NEXT">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._TO">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._FUNCTION">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._CALL">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._END">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._LOOP">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._WHILE">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._TRUE">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._FALSE">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._AS">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._IN">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._ASSIGN">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._NOUN">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._VERB">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._ADVERB">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._ADJECTIVE">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._PREPOSITION">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._CONJUNCTION">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._QUESTWORD">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._INTERJECTION">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._PRONOUN">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._PRONOUN_NAME">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._PRONOUN_PLACE">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._TRAANSITIVE_VERB">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._INTRANSITIVE_VERB">
    </member>
    <member name="F:AI_ZX81.ModuleKnowledgeStructures.TokenType._QUANTIFIER">
    </member>
    <member name="M:AI_ZX81.ModuleKnowledgeStructures.ExtractLastChar(System.String@)">
      <param name="InputStr">
</param>
    </member>
    <member name="M:AI_ZX81.ModuleKnowledgeStructures.ExtractFirstChar(System.String@)">
      <param name="InputStr">
</param>
    </member>
    <member name="M:AI_ZX81.ModuleKnowledgeStructures.Tokenizer(System.String@)">
      <summary>
Returns Characters in String as list</summary>
      <param name="InputStr">
</param>
    </member>
    <member name="T:AI_ZX81.FormDisplayConsole">
    </member>
    <member name="F:AI_ZX81.FormDisplayConsole.Globalvars">
    </member>
    <member name="F:AI_ZX81.FormDisplayConsole.LocalVars">
      <summary>
Uses Compiler Memory for Expressions</summary>
    </member>
    <member name="M:AI_ZX81.FormDisplayConsole.Print(System.String@)">
      <param name="Userinput">
</param>
    </member>
    <member name="M:AI_ZX81.FormDisplayConsole.CLS">
    </member>
    <member name="M:AI_ZX81.FormDisplayConsole.Input(System.String@)">
      <param name="Message">
</param>
    </member>
    <member name="M:AI_ZX81.FormDisplayConsole.Dispose(System.Boolean)">
      <param name="disposing">
</param>
    </member>
    <member name="F:AI_ZX81.FormDisplayConsole.components">
    </member>
    <member name="M:AI_ZX81.FormDisplayConsole.InitializeComponent">
    </member>
    <member name="N:AI_ZX81.STACK_VM">
    </member>
    <member name="T:AI_ZX81.STACK_VM.StackMemoryFrame">
      <summary>
Memory frame for Variables</summary>
    </member>
    <member name="T:AI_ZX81.STACK_VM.StackMemoryFrame.Var">
    </member>
    <member name="F:AI_ZX81.STACK_VM.StackMemoryFrame.Var.Value">
    </member>
    <member name="F:AI_ZX81.STACK_VM.StackMemoryFrame.Var.VarNumber">
    </member>
    <member name="F:AI_ZX81.STACK_VM.StackMemoryFrame.ReturnAddress">
    </member>
    <member name="F:AI_ZX81.STACK_VM.StackMemoryFrame.Variables">
    </member>
    <member name="M:AI_ZX81.STACK_VM.StackMemoryFrame.#ctor(System.Int32@)">
      <param name="ReturnAddress">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.StackMemoryFrame.GetReturnAddress">
    </member>
    <member name="M:AI_ZX81.STACK_VM.StackMemoryFrame.GetVar(System.String@)">
      <param name="VarNumber">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.StackMemoryFrame.SetVar(System.String@,System.Int32@)">
      <param name="VarNumber">
</param>
      <param name="value">
</param>
    </member>
    <member name="T:AI_ZX81.STACK_VM.ZX81_CPU">
      <summary>
SpydazWeb X86 Assembly language Virtual X86 Processor</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.GPU">
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_CPU.RunningState">
      <summary>
Used to monitor the Program status ; If the program is being executed then the cpu must be running the Property value can only be changed within the program</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.mRunningState">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.CPU_CACHE">
      <summary>
This is the cpu stack memory space; Items being interrogated will be placed in this memeory frame calling functions will access this frame ; the cpu stack can be considered to be a bus; Functions are devices / or gate logic which is connected to the bus via the cpu;</summary>
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_CPU.GetInstructionAddress">
      <summary>
Returns the Current position of the instruction Pointer in the Program being executed The instruction Pionet can be manipulated Jumping backwards and forwards in the program code.</summary>
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_CPU.Get_Instruction_Pointer_Position">
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_CPU.Get_Current_Stack_Data">
      <summary>
Returns the current data in the stack</summary>
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_CPU.View_C_P_U">
      <summary>
Returns the Current Cache (the stack)</summary>
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_CPU.Get_Current_Stack_Item">
      <summary>
Returns the current object on top of the stack</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.CPU_ERR">
      <summary>
Used to pass the intensive error messaging required;</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.ProgramData">
      <summary>
Used to hold the Program being sent to the CPU A list of objects has been chosen to allow for a Richer CPU enabling for objects to be passed instead of strings; due to this being a compiler as well as a morenized CPU converting strings to string or integers or booleans etc makes it much harder to create quick easy code; the sender is expeected to understand the logic of the items in the program the decoder only decodes bassed on what is expected;</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.InstructionAdrress">
      <summary>
the InstructionAdrress is the current position in the program; it could be considered to be the line numbe</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.PROCESS_NAME">
      <summary>
Name of current program or process running in CPU thread</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.CurrentCache">
      <summary>
Used for local memory frame</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.R_A_M">
      <summary>
Used to Store memory frames (The Heap)</summary>
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_CPU.View_R_A_M">
      <summary>
Returns the Ram as a Stack of Stack Memeory frames;</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.WaitTime">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.#ctor(System.String@)">
      <summary>
Each Program can be considered to be a task or thread; A name should be assigned to the Process; Processes themselves can be stacked in a higher level processor, allowing for paralel processing of code This process allows for the initialization of the CPU; THe Prgram will still need to be loaded</summary>
      <param name="ThreadName">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.#ctor(System.String@,System.Collections.Generic.List{System.String}@)">
      <summary>
Load Program and Executes Code on CPU</summary>
      <param name="ThreadName">
A name is required to Identify the Process</param>
      <param name="Program">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.LoadProgram(System.Collections.Generic.List{System.String}@)">
      <summary>
Loads items in to the program cache; this has been added to allow for continuious running of the VM the run/wait Command will be added to the assembler enabling for the pausing of the program and restarting of the program stack</summary>
      <param name="Prog">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.LoadProgram(System.Collections.Generic.List{System.Object}@)">
      <summary>
Loads items in to the program cache; this has been added to allow for continuious running of the VM the run/wait Command will be added to the assembler enabling for the pausing of the program and restarting of the program stack</summary>
      <param name="Prog">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.RUN">
      <summary>
Begins eexecution of the instructions held in program data</summary>
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_CPU.IsHalted">
      <summary>
Checks the status of the cpu</summary>
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_CPU.IsWait">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.EXECUTE">
      <summary>
Executes the next instruction in the Program Each Instruction is fed individually to the decoder : The Execute cycle Checks the Current State to determine if to fetch the next instruction to be decoded;(or EXECUTED) - The decoder contains the Chip logic</summary>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.Fetch">
      <summary>
Program Instructions can be boolean/String or integer so an object is assumed enabling for later classification of the instructions at the decoder level : The Fetch Cycle Fetches the next Instruction in the Program to be executed: It is fed to the decoder to be decoded and executed</summary>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.DECODE(System.Object@)">
      <summary>
Contains MainInstruction Set: Decode Cycle Decodes program instructions from the program the Insruction pointer points to the current Instruction being feed into the decoder: Important Note : the stack will always point to the data at top of the CPU CACHE (Which is Working Memory); THe memory frames being used are Extensions of this memeory and can be seen as registers, itself being a memory stack (stack of memory frames)</summary>
      <param name="ProgramInstruction">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.ToInt(System.Boolean@)">
      <param name="Bool">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.ToBool(System.Int32@)">
      <param name="Val">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.NOT_ToBool(System.Int32@)">
      <param name="Val">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.CheckJumpAddress(System.Int32@)">
      <summary>
Checks if there is a jump address available</summary>
      <param name="address">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.CheckThereIsAReturnAddress">
      <summary>
Function used by the internal functions to check if there is a return address</summary>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.GetCurrentFrame">
      <summary>
RAM is a STACK MEMORY - Here we can take a look at the stack item</summary>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.GetStackData">
      <summary>
Outputs stack data for verbose output</summary>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.ToJson(System.Object@)">
      <param name="OBJ">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.Peek">
      <summary>
REQUIRED TO SEE IN-SIDE CURRENT POINTER LOCATION ----------Public For Testing Purposes-----------</summary>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.BINARYOP(System.String@,System.Int32,System.Int32)">
      <param name="INSTRUCTION">
</param>
      <param name="LEFT">
</param>
      <param name="RIGHT">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.CheckStackHasAtLeastOneItem(System.Collections.Stack@)">
      <param name="Current">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.CheckStackHasAtLeastOneItem">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.CheckRamHasAtLeastOneItem">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.JumpIf_TRUE(System.Int32@)">
      <param name="Address">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.JUMP(System.Int32@)">
      <param name="Address">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.JumpIf_False(System.Int32@)">
      <param name="Address">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.Push(System.Object@)">
      <summary>
Puts a value on the cpu stack to be available to funcitons</summary>
      <param name="Value">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.Pop">
      <summary>
Pops a value of the cpu_Stack (current workspace)</summary>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.ToPositive(System.Int32)">
      <param name="Number">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.ToNegative(System.Int32)">
      <param name="Number">
</param>
    </member>
    <member name="T:AI_ZX81.STACK_VM.ZX81_CPU.State">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.State.RUN">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.State.HALT">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.State.PAUSE">
    </member>
    <member name="T:AI_ZX81.STACK_VM.ZX81_CPU.StackMemoryFrame">
      <summary>
Memory frame for Variables</summary>
    </member>
    <member name="T:AI_ZX81.STACK_VM.ZX81_CPU.StackMemoryFrame.Var">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.StackMemoryFrame.Var.Value">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.StackMemoryFrame.Var.VarNumber">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.StackMemoryFrame.ReturnAddress">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.StackMemoryFrame.Variables">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.StackMemoryFrame.#ctor(System.Int32@)">
      <param name="ReturnAddress">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.StackMemoryFrame.GetReturnAddress">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.StackMemoryFrame.GetVar(System.String@)">
      <param name="VarNumber">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.StackMemoryFrame.SetVar(System.String@,System.String@)">
      <param name="VarNumber">
</param>
      <param name="value">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.StackMemoryFrame.RemoveVar(System.String@)">
      <param name="VarNumber">
</param>
    </member>
    <member name="T:AI_ZX81.STACK_VM.ZX81_CPU.VM_ERR">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_ERR.ErrorStr">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_ERR.frm">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_ERR.CpuCurrentState">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.VM_ERR.#ctor(System.String@,AI_ZX81.STACK_VM.ZX81_CPU)">
      <param name="Err">
</param>
      <param name="CPUSTATE">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_CPU.VM_ERR.RaiseErr">
    </member>
    <member name="T:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds">
      <summary>
COMMANDS FOR ASSEMBLY LANGUAGE FOR THIS CPU SPYDAZWEB_VM_X86</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._NULL">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._REMOVE">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._RESUME">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._PUSH">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._PULL">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._PEEK">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._WAIT">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._PAUSE">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._HALT">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._DUP">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._JMP">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._JIF_T">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._JIF_F">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._JIF_EQ">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._JIF_GT">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._JIF_LT">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._LOAD">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._STORE">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._CALL">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._RET">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._PRINT_M">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._PRINT_C">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._ADD">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._SUB">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._MUL">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._DIV">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._AND">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._OR">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._NOT">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._IS_EQ">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._IS_GT">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._IS_GTE">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._IS_LT">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._IS_LTE">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._TO_POS">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._TO_NEG">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._INCR">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_CPU.VM_x86_Cmds._DECR">
    </member>
    <member name="T:AI_ZX81.STACK_VM.ZX81_GPU">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_GPU.iMonitorConsole">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_GPU.#ctor">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_GPU.ConsolePrint(System.String@)">
      <param name="Str">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_GPU.Console_CLS">
    </member>
    <member name="T:AI_ZX81.ZX81_RAM">
    </member>
    <member name="T:AI_ZX81.ZX81_RAM.Variable">
    </member>
    <member name="F:AI_ZX81.ZX81_RAM.Variable.iName">
    </member>
    <member name="F:AI_ZX81.ZX81_RAM.Variable.iValue">
    </member>
    <member name="F:AI_ZX81.ZX81_RAM.Variable.iType">
    </member>
    <member name="F:AI_ZX81.ZX81_RAM.CurrentVars">
      <summary>
Currently only Variables can be stored</summary>
    </member>
    <member name="M:AI_ZX81.ZX81_RAM.#ctor">
    </member>
    <member name="M:AI_ZX81.ZX81_RAM.UpdateVar(System.String@,System.String@)">
      <param name="VarName">
</param>
      <param name="iVALUE">
</param>
    </member>
    <member name="M:AI_ZX81.ZX81_RAM.RemoveVar(AI_ZX81.ZX81_RAM.Variable@)">
      <param name="Var">
</param>
    </member>
    <member name="M:AI_ZX81.ZX81_RAM.AddVar(AI_ZX81.ZX81_RAM.Variable@)">
      <param name="Var">
</param>
    </member>
    <member name="M:AI_ZX81.ZX81_RAM.CheckVar(System.String@)">
      <param name="VarName">
</param>
    </member>
    <member name="M:AI_ZX81.ZX81_RAM.GetVar(System.String@)">
      <param name="VarName">
</param>
    </member>
    <member name="T:AI_ZX81.STACK_VM.ZX81_VM">
      <summary>
Virtual Machine</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_VM.iProgram">
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_VM.Program">
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_VM.Name">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_VM.iname">
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_VM.iCPU">
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_VM.CPU">
    </member>
    <member name="P:AI_ZX81.STACK_VM.ZX81_VM.RAM">
      <summary>
To be used to store variables from functions/Expressions etc each string should be looked up in memeory</summary>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_VM.iRAM">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM.#ctor(System.String@)">
      <param name="iName">
</param>
    </member>
    <member name="F:AI_ZX81.STACK_VM.ZX81_VM.LineNumber">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM.ExecuteProgram">
      <summary>
Executes Program on CPU stack</summary>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM.ExecuteInstruction(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}@)">
      <param name="Item">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM.GetValue(System.String@)">
      <summary>
returns the value if it is a var it is returned as a value</summary>
      <param name="Val">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM._DIM_AS(System.String@,System.String@)">
      <summary>
Sets type of variable</summary>
      <param name="iTEM">
</param>
      <param name="iTYPE">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM._DIM_AS(System.String@,System.String@,System.String@)">
      <summary>
dims varibale as type and sets value</summary>
      <param name="iTEM">
</param>
      <param name="iTYPE">
</param>
      <param name="VALUE">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM._VAR_EQ_VALUE(System.String@,System.String@)">
      <summary>
Sets var eq to value</summary>
      <param name="iTEM">
</param>
      <param name="VALUE">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM.GetVarValue(System.String@)">
      <summary>
Returns var value as string value</summary>
      <param name="iName">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM.AddProgram(System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}@)">
      <param name="Program">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM.AddProgram(AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax@)">
      <param name="Statement">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM.ClearProgram">
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM.SetProgram(System.Collections.Generic.List{System.Collections.Generic.List{AI_ZX81.ModuleKnowledgeStructures.AbstractSyntax}}@)">
      <param name="ProgTree">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM._Binary_op(System.Int32@,System.Int32@,System.String@)">
      <param name="Left">
</param>
      <param name="Right">
</param>
      <param name="iOperator">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM._CheckCondition(System.Int32@,System.Int32@,System.String@)">
      <param name="Left">
</param>
      <param name="Right">
</param>
      <param name="iOperator">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM._print(System.String@)">
      <param name="Str">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM._if_then(System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
      <summary>
If ["condition"] Then ["If-True"] End</summary>
      <param name="_If">
If ["condition"]</param>
      <param name="_Then">
Then ["If-True"] End</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM._if_then_else(System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
      <summary>
If ["condition"] Then ["If-True"] ELSE ["If-False"] End</summary>
      <param name="_If">
If ["condition"]</param>
      <param name="_Then">
Then ["If-True"]</param>
      <param name="_Else">
ELSE ["If-False"]</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM._for(System.String@,System.Int32@,System.Int32@)">
      <param name="iVar">
</param>
      <param name="iStart">
</param>
      <param name="ifinish">
</param>
    </member>
    <member name="M:AI_ZX81.STACK_VM.ZX81_VM._next(System.String@)">
      <summary>
Executes next Cmd Increment by 1 if not greater than target return true if loop is required</summary>
      <returns>
True If loop is Required</returns>
      <param name="Ivar">
</param>
    </member>
    <member name="T:AI_ZX81.STACK_VM.instruction">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._halt">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._push">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._add">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._Sub">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._mul">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._div">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._Not">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._And">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._Or">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._pop">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._dup">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._is_eq">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._is_ge">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._is_gt">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._jmp">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._jif_t">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._jif_f">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._load">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._store">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._Call">
    </member>
    <member name="F:AI_ZX81.STACK_VM.instruction._ret">
    </member>
    <member name="N:AI_ZX81.My">
    </member>
    <member name="T:AI_ZX81.My.MyApplication">
    </member>
    <member name="M:AI_ZX81.My.MyApplication.#ctor">
    </member>
    <member name="M:AI_ZX81.My.MyApplication.OnCreateMainForm">
    </member>
    <member name="N:AI_ZX81.My.Resources">
    </member>
    <member name="T:AI_ZX81.My.Resources.Resources">
      <summary>
A strongly-typed resource class, for looking up localized strings, etc.</summary>
    </member>
    <member name="F:AI_ZX81.My.Resources.Resources.resourceMan">
    </member>
    <member name="F:AI_ZX81.My.Resources.Resources.resourceCulture">
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.ResourceManager">
      <summary>
Returns the cached ResourceManager instance used by this class.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.Culture">
      <summary>
Overrides the current thread's CurrentUICulture property for all resource lookups using this strongly typed resource class.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources._1200px_Computer_Retro_svg">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources._71nuo_ahpIL__AC_SL1500_">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.Apple_IIGS_Woz_edition2">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.awesome_amiga_500_plus_amiga_1200_computer">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.blue_apple_watch">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.Dell_UltraSharp_27">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.imac_mockup">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.ipad_mockup_768x1024">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.ipad_mockup_hands">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.iphone_6mockup">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.macbook_mockup">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.png_transparent_laptop_dell_xps_15_l502x_computer_keyboard_laptop_electronics_retro_computer_keyboard_thumbnail">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.png_transparent_zx_spectrum_vega_zx81_sinclair_research_computer_computer_electronics_computer_video_game">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.rick_sanchez_commodore_64_computer_cases_housings_disk_storage_commodore_international_morty_sanchez_thumbnail">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.samsung_mockup">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="P:AI_ZX81.My.Resources.Resources.smartwatch">
      <summary>
Looks up a localized resource of type System.Drawing.Bitmap.</summary>
    </member>
    <member name="T:AI_ZX81.My.MySettings">
    </member>
    <member name="F:AI_ZX81.My.MySettings.defaultInstance">
    </member>
    <member name="F:AI_ZX81.My.MySettings.addedHandler">
    </member>
    <member name="F:AI_ZX81.My.MySettings.addedHandlerLockObject">
    </member>
    <member name="M:AI_ZX81.My.MySettings.AutoSaveSettings(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="P:AI_ZX81.My.MySettings.Default">
    </member>
    <member name="T:AI_ZX81.My.MySettingsProperty">
    </member>
    <member name="P:AI_ZX81.My.MySettingsProperty.Settings">
    </member>
    <member name="N:AI_ZX81">
    </member>
  </members>
</doc>
