<?xml version="1.0"?>
<!--
Generated by VSdocman, see http://www.helixoft.com
-->
<doc>
  <assembly>
    <name>SPL_Small_Programming_Language</name>
  </assembly>
  <members>
    <member name="N:SDK.STACK_VM">
    </member>
    <member name="T:SDK.STACK_VM.X86API">
    </member>
    <member name="M:SDK.STACK_VM.X86API.RunMachineCode(System.String@)">
      <param name="Code">
</param>
    </member>
    <member name="F:SDK.STACK_VM.X86API.Tree">
    </member>
    <member name="T:SDK.STACK_VM.Ext">
    </member>
    <member name="M:SDK.STACK_VM.Ext.SplitAtNewLine(System.String)">
      <param name="input">
</param>
    </member>
    <member name="M:SDK.STACK_VM.Ext.ExtractLastChar(System.String@)">
      <param name="InputStr">
</param>
    </member>
    <member name="M:SDK.STACK_VM.Ext.ExtractFirstChar(System.String@)">
      <param name="InputStr">
</param>
    </member>
    <member name="T:SDK.STACK_VM.SalCode_Helpers">
    </member>
    <member name="M:SDK.STACK_VM.SalCode_Helpers._Binary_op(System.Int32@,System.Int32@,System.String@)">
      <param name="Left">
</param>
      <param name="Right">
</param>
      <param name="iOperator">
</param>
    </member>
    <member name="M:SDK.STACK_VM.SalCode_Helpers._CheckCondition(System.Int32@,System.Int32@,System.String@)">
      <param name="Left">
</param>
      <param name="Right">
</param>
      <param name="iOperator">
</param>
    </member>
    <member name="M:SDK.STACK_VM.SalCode_Helpers._print(System.String@)">
      <param name="Str">
</param>
    </member>
    <member name="M:SDK.STACK_VM.SalCode_Helpers._if_then(System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
      <summary>
If ["condition"] Then ["If-True"] End</summary>
      <param name="_If">
If ["condition"]</param>
      <param name="_Then">
Then ["If-True"] End</param>
    </member>
    <member name="M:SDK.STACK_VM.SalCode_Helpers._if_then_else(System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
      <summary>
If ["condition"] Then ["If-True"] ELSE ["If-False"] End</summary>
      <param name="_If">
If ["condition"]</param>
      <param name="_Then">
Then ["If-True"]</param>
      <param name="_Else">
ELSE ["If-False"]</param>
    </member>
    <member name="T:SDK.FormDisplayConsole">
    </member>
    <member name="M:SDK.FormDisplayConsole.Print(System.String@)">
      <param name="Userinput">
</param>
    </member>
    <member name="M:SDK.FormDisplayConsole.CLS">
    </member>
    <member name="M:SDK.FormDisplayConsole.Input(System.String@)">
      <param name="Message">
</param>
    </member>
    <member name="M:SDK.FormDisplayConsole.Dispose(System.Boolean)">
      <param name="disposing">
</param>
    </member>
    <member name="F:SDK.FormDisplayConsole.components">
    </member>
    <member name="M:SDK.FormDisplayConsole.InitializeComponent">
    </member>
    <member name="T:SDK.VM_MachineUI">
    </member>
    <member name="M:SDK.VM_MachineUI.ExecuteCode(System.String@)">
      <param name="Code">
</param>
    </member>
    <member name="M:SDK.VM_MachineUI.ButtonRunCode_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.VM_MachineUI.ButtonNewScrn_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.VM_MachineUI.ButtonClrScrn_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.VM_MachineUI.Dispose(System.Boolean)">
      <param name="disposing">
</param>
    </member>
    <member name="F:SDK.VM_MachineUI.components">
    </member>
    <member name="M:SDK.VM_MachineUI.InitializeComponent">
    </member>
    <member name="T:SDK.STACK_VM.StackMemoryFrame">
      <summary>
Memory frame for Variables</summary>
    </member>
    <member name="T:SDK.STACK_VM.StackMemoryFrame.Var">
    </member>
    <member name="F:SDK.STACK_VM.StackMemoryFrame.Var.Value">
    </member>
    <member name="F:SDK.STACK_VM.StackMemoryFrame.Var.VarNumber">
    </member>
    <member name="F:SDK.STACK_VM.StackMemoryFrame.ReturnAddress">
    </member>
    <member name="F:SDK.STACK_VM.StackMemoryFrame.Variables">
    </member>
    <member name="M:SDK.STACK_VM.StackMemoryFrame.#ctor(System.Int32@)">
      <param name="ReturnAddress">
</param>
    </member>
    <member name="M:SDK.STACK_VM.StackMemoryFrame.GetReturnAddress">
    </member>
    <member name="M:SDK.STACK_VM.StackMemoryFrame.GetVar(System.String@)">
      <param name="VarNumber">
</param>
    </member>
    <member name="M:SDK.STACK_VM.StackMemoryFrame.SetVar(System.String@,System.Int32@)">
      <param name="VarNumber">
</param>
      <param name="value">
</param>
    </member>
    <member name="T:SDK.STACK_VM.ZX81_CPU">
      <summary>
SpydazWeb X86 Assembly language Virtual X86 Processor</summary>
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.GPU">
    </member>
    <member name="P:SDK.STACK_VM.ZX81_CPU.RunningState">
      <summary>
Used to monitor the Program status ; If the program is being executed then the cpu must be running the Property value can only be changed within the program</summary>
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.mRunningState">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.CPU_CACHE">
      <summary>
This is the cpu stack memory space; Items being interrogated will be placed in this memeory frame calling functions will access this frame ; the cpu stack can be considered to be a bus; Functions are devices / or gate logic which is connected to the bus via the cpu;</summary>
    </member>
    <member name="P:SDK.STACK_VM.ZX81_CPU.GetInstructionAddress">
      <summary>
Returns the Current position of the instruction Pointer in the Program being executed The instruction Pionet can be manipulated Jumping backwards and forwards in the program code.</summary>
    </member>
    <member name="P:SDK.STACK_VM.ZX81_CPU.Get_Instruction_Pointer_Position">
    </member>
    <member name="P:SDK.STACK_VM.ZX81_CPU.Get_Current_Stack_Data">
      <summary>
Returns the current data in the stack</summary>
    </member>
    <member name="P:SDK.STACK_VM.ZX81_CPU.View_C_P_U">
      <summary>
Returns the Current Cache (the stack)</summary>
    </member>
    <member name="P:SDK.STACK_VM.ZX81_CPU.Get_Current_Stack_Item">
      <summary>
Returns the current object on top of the stack</summary>
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.CPU_ERR">
      <summary>
Used to pass the intensive error messaging required;</summary>
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.ProgramData">
      <summary>
Used to hold the Program being sent to the CPU A list of objects has been chosen to allow for a Richer CPU enabling for objects to be passed instead of strings; due to this being a compiler as well as a morenized CPU converting strings to string or integers or booleans etc makes it much harder to create quick easy code; the sender is expeected to understand the logic of the items in the program the decoder only decodes bassed on what is expected;</summary>
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.InstructionAdrress">
      <summary>
the InstructionAdrress is the current position in the program; it could be considered to be the line numbe</summary>
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.PROCESS_NAME">
      <summary>
Name of current program or process running in CPU thread</summary>
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.CurrentCache">
      <summary>
Used for local memory frame</summary>
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.R_A_M">
      <summary>
Used to Store memory frames (The Heap)</summary>
    </member>
    <member name="P:SDK.STACK_VM.ZX81_CPU.View_R_A_M">
      <summary>
Returns the Ram as a Stack of Stack Memeory frames;</summary>
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.WaitTime">
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.#ctor(System.String@)">
      <summary>
Each Program can be considered to be a task or thread; A name should be assigned to the Process; Processes themselves can be stacked in a higher level processor, allowing for paralel processing of code This process allows for the initialization of the CPU; THe Prgram will still need to be loaded</summary>
      <param name="ThreadName">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.#ctor(System.String@,System.Collections.Generic.List{System.String}@)">
      <summary>
Load Program and Executes Code on CPU</summary>
      <param name="ThreadName">
A name is required to Identify the Process</param>
      <param name="Program">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.LoadProgram(System.Collections.Generic.List{System.String}@)">
      <summary>
Loads items in to the program cache; this has been added to allow for continuious running of the VM the run/wait Command will be added to the assembler enabling for the pausing of the program and restarting of the program stack</summary>
      <param name="Prog">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.LoadProgram(System.Collections.Generic.List{System.Object}@)">
      <summary>
Loads items in to the program cache; this has been added to allow for continuious running of the VM the run/wait Command will be added to the assembler enabling for the pausing of the program and restarting of the program stack</summary>
      <param name="Prog">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.RUN">
      <summary>
Begins eexecution of the instructions held in program data</summary>
    </member>
    <member name="P:SDK.STACK_VM.ZX81_CPU.IsHalted">
      <summary>
Checks the status of the cpu</summary>
    </member>
    <member name="P:SDK.STACK_VM.ZX81_CPU.IsWait">
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.EXECUTE">
      <summary>
Executes the next instruction in the Program Each Instruction is fed individually to the decoder : The Execute cycle Checks the Current State to determine if to fetch the next instruction to be decoded;(or EXECUTED) - The decoder contains the Chip logic</summary>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.Fetch">
      <summary>
Program Instructions can be boolean/String or integer so an object is assumed enabling for later classification of the instructions at the decoder level : The Fetch Cycle Fetches the next Instruction in the Program to be executed: It is fed to the decoder to be decoded and executed</summary>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.DECODE(System.Object@)">
      <summary>
Contains MainInstruction Set: Decode Cycle Decodes program instructions from the program the Insruction pointer points to the current Instruction being feed into the decoder: Important Note : the stack will always point to the data at top of the CPU CACHE (Which is Working Memory); THe memory frames being used are Extensions of this memeory and can be seen as registers, itself being a memory stack (stack of memory frames)</summary>
      <param name="ProgramInstruction">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.ToInt(System.Boolean@)">
      <param name="Bool">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.ToBool(System.Int32@)">
      <param name="Val">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.NOT_ToBool(System.Int32@)">
      <param name="Val">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.CheckJumpAddress(System.Int32@)">
      <summary>
Checks if there is a jump address available</summary>
      <param name="address">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.CheckThereIsAReturnAddress">
      <summary>
Function used by the internal functions to check if there is a return address</summary>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.GetCurrentFrame">
      <summary>
RAM is a STACK MEMORY - Here we can take a look at the stack item</summary>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.GetStackData">
      <summary>
Outputs stack data for verbose output</summary>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.ToJson(System.Object@)">
      <param name="OBJ">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.Peek">
      <summary>
REQUIRED TO SEE IN-SIDE CURRENT POINTER LOCATION ----------Public For Testing Purposes-----------</summary>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.BINARYOP(System.String@,System.Int32,System.Int32)">
      <param name="INSTRUCTION">
</param>
      <param name="LEFT">
</param>
      <param name="RIGHT">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.CheckStackHasAtLeastOneItem(System.Collections.Stack@)">
      <param name="Current">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.CheckStackHasAtLeastOneItem">
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.CheckRamHasAtLeastOneItem">
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.JumpIf_TRUE(System.Int32@)">
      <param name="Address">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.JUMP(System.Int32@)">
      <param name="Address">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.JumpIf_False(System.Int32@)">
      <param name="Address">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.Push(System.Object@)">
      <summary>
Puts a value on the cpu stack to be available to funcitons</summary>
      <param name="Value">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.Pop">
      <summary>
Pops a value of the cpu_Stack (current workspace)</summary>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.ToPositive(System.Int32)">
      <param name="Number">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.ToNegative(System.Int32)">
      <param name="Number">
</param>
    </member>
    <member name="T:SDK.STACK_VM.ZX81_CPU.State">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.State.RUN">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.State.HALT">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.State.PAUSE">
    </member>
    <member name="T:SDK.STACK_VM.ZX81_CPU.StackMemoryFrame">
      <summary>
Memory frame for Variables</summary>
    </member>
    <member name="T:SDK.STACK_VM.ZX81_CPU.StackMemoryFrame.Var">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.StackMemoryFrame.Var.Value">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.StackMemoryFrame.Var.VarNumber">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.StackMemoryFrame.ReturnAddress">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.StackMemoryFrame.Variables">
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.StackMemoryFrame.#ctor(System.Int32@)">
      <param name="ReturnAddress">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.StackMemoryFrame.GetReturnAddress">
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.StackMemoryFrame.GetVar(System.String@)">
      <param name="VarNumber">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.StackMemoryFrame.SetVar(System.String@,System.String@)">
      <param name="VarNumber">
</param>
      <param name="value">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.StackMemoryFrame.RemoveVar(System.String@)">
      <param name="VarNumber">
</param>
    </member>
    <member name="T:SDK.STACK_VM.ZX81_CPU.VM_ERR">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_ERR.ErrorStr">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_ERR.frm">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_ERR.CpuCurrentState">
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.VM_ERR.#ctor(System.String@,SDK.STACK_VM.ZX81_CPU)">
      <param name="Err">
</param>
      <param name="CPUSTATE">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_CPU.VM_ERR.RaiseErr">
    </member>
    <member name="T:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds">
      <summary>
COMMANDS FOR ASSEMBLY LANGUAGE FOR THIS CPU SPYDAZWEB_VM_X86</summary>
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._NULL">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._REMOVE">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._RESUME">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._PUSH">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._PULL">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._PEEK">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._WAIT">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._PAUSE">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._HALT">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._DUP">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._JMP">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._JIF_T">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._JIF_F">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._JIF_EQ">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._JIF_GT">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._JIF_LT">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._LOAD">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._STORE">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._CALL">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._RET">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._PRINT_M">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._PRINT_C">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._ADD">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._SUB">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._MUL">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._DIV">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._AND">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._OR">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._NOT">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._IS_EQ">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._IS_GT">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._IS_GTE">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._IS_LT">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._IS_LTE">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._TO_POS">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._TO_NEG">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._INCR">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_CPU.VM_x86_Cmds._DECR">
    </member>
    <member name="T:SDK.STACK_VM.ZX81_GPU">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_GPU.iMonitorConsole">
    </member>
    <member name="M:SDK.STACK_VM.ZX81_GPU.#ctor">
    </member>
    <member name="M:SDK.STACK_VM.ZX81_GPU.ConsolePrint(System.String@)">
      <param name="Str">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_GPU.Console_CLS">
    </member>
    <member name="T:SDK.STACK_VM.ZX81_RAM">
    </member>
    <member name="T:SDK.STACK_VM.ZX81_RAM.Variable">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_RAM.Variable.iName">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_RAM.Variable.iValue">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_RAM.Variable.iType">
    </member>
    <member name="F:SDK.STACK_VM.ZX81_RAM.CurrentVars">
      <summary>
Currently only Variables can be stored</summary>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_RAM.#ctor">
    </member>
    <member name="M:SDK.STACK_VM.ZX81_RAM.UpdateVar(System.String@,System.String@)">
      <param name="VarName">
</param>
      <param name="iVALUE">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_RAM.RemoveVar(SDK.STACK_VM.ZX81_RAM.Variable@)">
      <param name="Var">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_RAM.AddVar(SDK.STACK_VM.ZX81_RAM.Variable@)">
      <param name="Var">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_RAM.CheckVar(System.String@)">
      <param name="VarName">
</param>
    </member>
    <member name="M:SDK.STACK_VM.ZX81_RAM.GetVar(System.String@)">
      <param name="VarName">
</param>
    </member>
    <member name="T:SDK.Token">
      <summary>
Token to be returned</summary>
    </member>
    <member name="F:SDK.Token.ID">
      <summary>
Simple identifier</summary>
    </member>
    <member name="F:SDK.Token.Value">
      <summary>
Held Data</summary>
    </member>
    <member name="F:SDK.Token._start">
      <summary>
Start of token(Start position)</summary>
    </member>
    <member name="F:SDK.Token._End">
      <summary>
End of token (end Position)</summary>
    </member>
    <member name="M:SDK.Token.ToJson">
    </member>
    <member name="T:SDK.Lexer">
    </member>
    <member name="F:SDK.Lexer.Cursor">
      <summary>
Cursor Position</summary>
    </member>
    <member name="F:SDK.Lexer.EoFCursor">
      <summary>
Cursor Position</summary>
    </member>
    <member name="F:SDK.Lexer.CurrentScript">
      <summary>
Program being Tokenized</summary>
    </member>
    <member name="F:SDK.Lexer.iPastTokens">
    </member>
    <member name="F:SDK.Lexer.iLastToken">
    </member>
    <member name="P:SDK.Lexer.PastTokens">
    </member>
    <member name="P:SDK.Lexer.LastToken">
    </member>
    <member name="M:SDK.Lexer.GetLastToken">
    </member>
    <member name="M:SDK.Lexer.GetSlice(System.String@,System.Int32@)">
      <summary>
Returns from index to end of file (Universal function)</summary>
      <param name="Str">
String</param>
      <param name="indx">
Index</param>
    </member>
    <member name="P:SDK.Lexer.EndOfFile">
    </member>
    <member name="M:SDK.Lexer.GetNext">
      <summary>
Gets next token moves cursor forwards</summary>
    </member>
    <member name="M:SDK.Lexer.ViewNext">
      <summary>
Checks token without moving the cursor</summary>
    </member>
    <member name="M:SDK.Lexer.RegExSearch(System.String@,System.String)">
      <summary>
Main Searcher</summary>
      <param name="Text">
to be searched</param>
      <param name="Pattern">
RegEx Search String</param>
    </member>
    <member name="M:SDK.Lexer.StepBack(System.String@)">
      <summary>
Steps the tokenizer backwards</summary>
      <param name="TokenStr">
</param>
    </member>
    <member name="M:SDK.Lexer.Eat(SDK.GrammarFactory.Grammar.Type_Id@)">
      <param name="TokenType">
</param>
    </member>
    <member name="M:SDK.Lexer.IdentifiyToken(System.String@)">
      <summary>
Identifys token</summary>
      <param name="CurrentTok">
</param>
    </member>
    <member name="M:SDK.Lexer.GetIdentifiedToken(System.String@)">
      <summary>
Identifys token</summary>
      <param name="CurrentTok">
</param>
    </member>
    <member name="F:SDK.Lexer.CurrentGrammar">
    </member>
    <member name="M:SDK.Lexer.#ctor(System.String@)">
      <param name="Script">
</param>
    </member>
    <member name="M:SDK.Lexer.#ctor(System.String@,System.Collections.Generic.List{SDK.GrammarFactory.Grammar}@)">
      <param name="Script">
</param>
      <param name="Grammar">
</param>
    </member>
    <member name="T:SDK.EXT">
      <summary>
Minor Extension Methods; Required for json formatting</summary>
    </member>
    <member name="M:SDK.EXT.FormatJsonOutput(System.String)">
      <param name="jsonString">
</param>
    </member>
    <member name="M:SDK.EXT.ToJson(System.Object@)">
      <param name="item">
</param>
    </member>
    <member name="T:SDK.GrammarFactory">
    </member>
    <member name="T:SDK.GrammarFactory.Grammar">
      <summary>
Simple Gramar object (Expected token Shape or from)</summary>
    </member>
    <member name="T:SDK.GrammarFactory.Grammar.Type_Id">
      <summary>
GRAMMAR OBJECT ID</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._INTEGER">
      <summary>
Literal</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._STRING">
      <summary>
Literal</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._VARIABLE">
      <summary>
Literal</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._WHITESPACE">
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._COMMENTS">
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._PRINT">
      <summary>
Print Literal/Value/String</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._DIM">
      <summary>
Declare Var</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._FOR">
      <summary>
Begin Iteration of list For (Iterator = (Increment to Completion)</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._EACH">
      <summary>
Additional = Step +1</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._IN">
      <summary>
From item in list</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._TO">
      <summary>
End of iteration marker</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._NEXT">
      <summary>
Increment Iterator</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._IF">
      <summary>
If Condition = Outcome Then (code) Else (code)</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._THEN">
      <summary>
Then (block)</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._ELSE">
      <summary>
Else (Block)</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._UNTIL">
      <summary>
Until Condition = true</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._WHILE">
      <summary>
While Condition = true</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._DO">
      <summary>
Signify begining of Do...While/Until</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._RETURN">
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._FUNCTION">
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._SUB">
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._CLASS">
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._NEW">
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._AS">
      <summary>
Used in Declaration Assignment Left (var) assign as (LiteralType)</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._LOOP">
      <summary>
End of While loop (marker)(check expression Condition)</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._SIMPLE_ASSIGN">
      <summary>
xLeft = output of right (9+4) (+= 9) (-=2) (3) (true)</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._COMPLEX_ASSIGN">
      <summary>
xLeft assigns output of right -=(9+4) (+= 9) (-=2) (3) (true) Complex assign ... x=x+(ouput)x=x-(ouput) etc</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._TRUE">
      <summary>
Boolean Literal Env Variable</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._FALSE">
      <summary>
Boolean Literal - Env Variable</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._NULL">
      <summary>
Boolean literal -Env Variable</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._LIST_BEGIN">
      <summary>
Used for Args List (Lists) = Arrays Args are lists of Vars (function Environment Vars)</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._LIST_END">
      <summary>
End of List</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._CODE_BEGIN">
      <summary>
Used for Blocks of code</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._CODE_END">
      <summary>
End of Code block</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._CONDITIONAL_BEGIN">
      <summary>
Used for operation blocks as well as ordering prioritizing evals Begin</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._CONDITIONAL_END">
      <summary>
End of Condition</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._LOGICAL_AND">
      <summary>
- AND</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._LOGICAL_OR">
      <summary>
| OR</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._LOGICAL_NOT">
      <summary>
! NOT</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._RELATIONAL_OPERATOR">
      <summary>
Greater than / Less Than</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._ADDITIVE_OPERATOR">
      <summary>
+-</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._MULTIPLICATIVE_OPERATOR">
      <summary>
*/</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._STATEMENT_END">
      <summary>
;</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._EOF">
      <summary>
end of file</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._BAD_TOKEN">
      <summary>
Bad / Unrecognized token</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._LIST_SEPERATOR">
      <summary>
Seperates items in list</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._NOT_EQUALS">
      <summary>
!=</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Type_Id._VARIABLE_DECLARE">
      <summary>
DECLARE VAR</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.ID">
      <summary>
Identifier</summary>
    </member>
    <member name="F:SDK.GrammarFactory.Grammar.Exp">
      <summary>
RegEx Expression to search</summary>
    </member>
    <member name="M:SDK.GrammarFactory.Grammar.GetGrammar">
      <summary>
Set OF KeyWords for Language with RegEx Search Expressions Based on basic programming languge keywords and symbols /Literals This is a preloaded Grammar (list of Grammar objects)</summary>
    </member>
    <member name="T:SDK.Ast_ExpressionFactory">
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.AST_NODE">
      <summary>
Ast NodeTypes Used to Describe AST Node</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._array">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._boolean">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._string">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._integer">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._variable">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._null">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._endStatement">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._blockCode">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._binaryExpression">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._OperationalExpression">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._MultiplicativeExpression">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._AddativeExpression">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._assignExpression">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._Dim">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._For">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._If">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._function">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._sub">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._class">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._else">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._then">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._Do_while">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._Do_until">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._Program">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._comments">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._ExpressionStatement">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._WhiteSpace">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._UnknownStatement">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._Code_Begin">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._Code_End">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._emptyStatement">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._OperationBegin">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._OperationEnd">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AST_NODE._ConditionalExpression">
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.Ast_Identifier">
      <summary>
Syntax: Used to hold Varnames or Identifiers</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.Ast_Identifier._Name">
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_Identifier.#ctor(System.String@)">
      <param name="nName">
</param>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_Identifier.ToArraylist">
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.Ast_Literal">
      <summary>
Syntax: Used to hold Literals and values</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.Ast_Literal.iLiteral">
      <summary>
Holds value (in its type)</summary>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_Literal.#ctor(SDK.Ast_ExpressionFactory.AST_NODE@)">
      <param name="ntype">
</param>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_Literal.#ctor(SDK.Ast_ExpressionFactory.AST_NODE@,System.Object@)">
      <param name="ntype">
</param>
      <param name="nValue">
</param>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_Literal.ToArraylist">
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.AstNode">
      <summary>
Syntax: Root Ast node Type</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AstNode._Type">
      <summary>
Type Of Node</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AstNode._TypeStr">
      <summary>
String version of the Type due to not being printed</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AstNode._Start">
      <summary>
Start Position</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AstNode._End">
      <summary>
End Position</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AstNode._Raw">
      <summary>
Raw data of token</summary>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.AstNode.#ctor(SDK.Ast_ExpressionFactory.AST_NODE@)">
      <summary>
Instanciate</summary>
      <param name="ntype">
Type of Node</param>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.AstNode.ToArraylist">
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.AstExpression">
      <summary>
Expression Model Used To Group Expressions</summary>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.AstExpression.#ctor(SDK.Ast_ExpressionFactory.AST_NODE@)">
      <param name="ntype">
</param>
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.Ast_ExpressionStatement">
      <summary>
Syntax: Expression Statement Types</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.Ast_ExpressionStatement._Expression">
      <summary>
Literal Value</summary>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_ExpressionStatement.#ctor(SDK.Ast_ExpressionFactory.Ast_Literal@)">
      <param name="nValue">
Literal Value to be stored</param>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_ExpressionStatement.ToArraylist">
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.Ast_VariableExpressionStatement">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.Ast_VariableExpressionStatement._Expression">
      <summary>
Literal Value</summary>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_VariableExpressionStatement.#ctor(SDK.Ast_ExpressionFactory.Ast_Identifier@)">
      <param name="nValue">
Literal Value to be stored</param>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_VariableExpressionStatement.ToArraylist">
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.AstProgram">
      <summary>
Syntax : Based on AST Explorer output { "type": "Program", "start": 0, "end": 2, "body": [ { "type": "ExpressionStatement", "start": 0, "end": 2, "expression": { "type": "Literal", "start": 0, "end": 2, "value": 42, "raw": "42" } } ], }</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AstProgram.Body">
      <summary>
Expression List</summary>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.AstProgram.#ctor(System.Collections.Generic.List{SDK.Ast_ExpressionFactory.AstExpression}@)">
      <summary>
Instanciate Expression</summary>
      <param name="nBody">
Expressions</param>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.AstProgram.ToArraylist">
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.AstBinaryExpression">
      <summary>
Used for Binary Operations</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AstBinaryExpression._Left">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AstBinaryExpression._Right">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.AstBinaryExpression._Operator">
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.AstBinaryExpression.#ctor(SDK.Ast_ExpressionFactory.AST_NODE@,SDK.Ast_ExpressionFactory.AstExpression@,System.String@,SDK.Ast_ExpressionFactory.AstExpression@)">
      <param name="nType">
</param>
      <param name="nLeft">
</param>
      <param name="nOperator">
</param>
      <param name="nRight">
</param>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.AstBinaryExpression.ToArraylist">
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.Ast_AssignmentExpression">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.Ast_AssignmentExpression._Left">
      <summary>
Must be var literal type</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.Ast_AssignmentExpression._Right">
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.Ast_AssignmentExpression._Operator">
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_AssignmentExpression.#ctor(SDK.Ast_ExpressionFactory.Ast_Identifier@,System.String@,SDK.Ast_ExpressionFactory.AstExpression@)">
      <param name="nLeft">
</param>
      <param name="nOperator">
</param>
      <param name="nRight">
</param>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_AssignmentExpression.ToArrayList">
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.Ast_BlockExpression">
      <summary>
Used for CodeBlocks</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.Ast_BlockExpression.Body">
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_BlockExpression.#ctor(System.Collections.Generic.List{SDK.Ast_ExpressionFactory.Ast_ExpressionStatement}@)">
      <param name="iBody">
</param>
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_BlockExpression.ToArraylist">
    </member>
    <member name="T:SDK.Ast_ExpressionFactory.Ast_ParenthesizedExpresion">
      <summary>
Used for Operational Expression</summary>
    </member>
    <member name="F:SDK.Ast_ExpressionFactory.Ast_ParenthesizedExpresion.Body">
    </member>
    <member name="M:SDK.Ast_ExpressionFactory.Ast_ParenthesizedExpresion.#ctor(System.Collections.Generic.List{SDK.Ast_ExpressionFactory.AstExpression}@)">
      <param name="iBody">
</param>
    </member>
    <member name="T:SDK.ReplErrorSystem">
    </member>
    <member name="M:SDK.ReplErrorSystem.DisplayError(System.String@,SDK.Ast_ExpressionFactory.Ast_Literal@)">
      <summary>
Creates an Error Message to be displayed</summary>
      <param name="ErrorStr">
</param>
      <param name="Errtok">
</param>
    </member>
    <member name="T:SDK.Parser">
      <summary>
Programming Language Parser to AST</summary>
    </member>
    <member name="F:SDK.Parser.ParserErrors">
    </member>
    <member name="F:SDK.Parser.iScript">
      <summary>
Currently held script</summary>
    </member>
    <member name="F:SDK.Parser.Lookahead">
      <summary>
To hold the look ahead value without consuming the value</summary>
    </member>
    <member name="F:SDK.Parser.Tokenizer">
      <summary>
Tokenizer !</summary>
    </member>
    <member name="M:SDK.Parser.Parse(System.String@)">
      <summary>
Main Parser Function Parses whole Script into a AST tree ; Which can be used later for evaluation to be run on a vm or to generate code for a different language (interpretor) or (evaluator - Compiler(Executor)</summary>
      <returns>
AST PROGRAM</returns>
      <param name="nScript">
Script to be compiled</param>
    </member>
    <member name="M:SDK.Parser.Parse(System.String@,System.Collections.Generic.List{SDK.GrammarFactory.Grammar}@)">
      <summary>
Main Parser Function Parses whole Script into a AST tree ; Which can be used later for evaluation to be run on a vm or to generate code for a different language (interpretor) or (evaluator - Compiler(Executor)</summary>
      <returns>
AST PROGRAM</returns>
      <param name="nScript">
Script to be compiled</param>
      <param name="Gramer">
Uses Custom Grammar to create tokens</param>
    </member>
    <member name="M:SDK.Parser._ProgramNode">
      <summary>
Main Entry Point. Syntax: Program: -Literals</summary>
    </member>
    <member name="M:SDK.Parser._StatementList">
      <summary>
Syntax -Statement -Statementlist Statement -&gt; Statement Statement Statement</summary>
    </member>
    <member name="M:SDK.Parser._PrimaryExpression">
      <summary>
Syntax -Literal =&gt; (_PrimaryExpression)</summary>
    </member>
    <member name="M:SDK.Parser._literalNode">
      <summary>
-Literals Syntax: -Numeric Literal -String Literal -Comments -Nullable</summary>
    </member>
    <member name="M:SDK.Parser._NumericLiteralNode">
      <summary>
Syntax: Numeric Literal: -Number</summary>
    </member>
    <member name="M:SDK.Parser._NullableNode">
      <summary>
Syntax: Nullable Literal: -Null</summary>
    </member>
    <member name="M:SDK.Parser.__EmptyStatementNode">
      <summary>
Used for end of statement</summary>
    </member>
    <member name="M:SDK.Parser.__EndStatementNode">
    </member>
    <member name="M:SDK.Parser.__UnknownStatementNode">
      <summary>
Collects bad token</summary>
    </member>
    <member name="M:SDK.Parser.__UnknownStatementNode(SDK.Token@)">
      <summary>
Used when data has already been collected</summary>
      <param name="ErrorTok">
</param>
    </member>
    <member name="M:SDK.Parser._WhitespaceNode">
      <summary>
Used to denote white space as it is often important later Some Parsers ignore this token ; It is thought also; to be prudent to collect all tokens to let the Evaluator deal with this later</summary>
    </member>
    <member name="M:SDK.Parser._CodeBeginNode">
      <summary>
Used to Eat Node</summary>
    </member>
    <member name="M:SDK.Parser._ConditionalBeginNode">
    </member>
    <member name="M:SDK.Parser._CodeEndNode">
      <summary>
Used to Eat Node</summary>
    </member>
    <member name="M:SDK.Parser._ConditionalEndNode">
    </member>
    <member name="M:SDK.Parser._BooleanNode">
      <summary>
Used to return boolean literals if badly detected it will return false</summary>
    </member>
    <member name="M:SDK.Parser._CommentsNode">
      <summary>
Syntax: Comments Literal: -Comments</summary>
    </member>
    <member name="M:SDK.Parser._StringLiteralNode">
      <summary>
Syntax: "hjk" String Literal: -String</summary>
    </member>
    <member name="M:SDK.Parser._IdentifierLiteralNode">
    </member>
    <member name="M:SDK.Parser._Statement">
      <summary>
Syntax -ExpressionStatement -BlockStatement -IterationStatement</summary>
    </member>
    <member name="M:SDK.Parser._ExpressionStatement">
      <summary>
Gets Expression Statement Syntax -Expression ";"</summary>
    </member>
    <member name="M:SDK.Parser._Expression">
      <summary>
Syntax: -_PrimaryExpression(literal) -_MultiplicativeExpression -_AddativeExpression</summary>
    </member>
    <member name="M:SDK.Parser._BlockStatement">
      <summary>
Syntax: Could be Empty list So Prefix Optional { OptionalStatmentList }</summary>
    </member>
    <member name="M:SDK.Parser._VariableExpression">
      <summary>
Syntax: Variable: -Identifier as expression</summary>
    </member>
    <member name="M:SDK.Parser._ParenthesizedExpression">
      <summary>
Syntax: ( OptionalStatmentList; )</summary>
    </member>
    <member name="M:SDK.Parser._MultiplicativeExpression">
      <summary>
Syntax: -Multiplicative Expression Literal */ Literal</summary>
    </member>
    <member name="M:SDK.Parser._AddativeExpression">
      <summary>
Syntax: -Addative Expression Literal +- Literal</summary>
    </member>
    <member name="M:SDK.Parser._RelationalExpression">
      <summary>
Syntax: Literal Operator Literal _BinaryExpression RelationalOperator _BinaryExpression ..</summary>
    </member>
    <member name="M:SDK.Parser._BinaryExpression(SDK.GrammarFactory.Grammar.Type_Id@,SDK.Ast_ExpressionFactory.AST_NODE,System.String)">
      <summary>
syntax: -Literal(Primary Expression) -Multiplicative Expression -Addative Expression -ConditionalExpression(OperationalExpression) -Assignment Expression</summary>
      <param name="NType">
</param>
      <param name="AstType">
</param>
      <param name="AstTypeStr">
</param>
    </member>
    <member name="M:SDK.Parser._BinaryExpression">
    </member>
    <member name="M:SDK.Parser._IterationStatment">
      <summary>
Syntax -DoWhile -DoUntil _ForNext</summary>
    </member>
    <member name="T:SDK.FormREPL">
    </member>
    <member name="M:SDK.FormREPL.ToolStripButtonCompile_Click(System.Object,System.EventArgs)">
      <param name="sender">
</param>
      <param name="e">
</param>
    </member>
    <member name="M:SDK.FormREPL.Dispose(System.Boolean)">
      <param name="disposing">
</param>
    </member>
    <member name="F:SDK.FormREPL.components">
    </member>
    <member name="M:SDK.FormREPL.InitializeComponent">
    </member>
    <member name="N:SDK">
    </member>
  </members>
</doc>
